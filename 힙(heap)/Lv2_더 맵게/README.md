[문제링크](https://programmers.co.kr/learn/courses/30/lessons/42626)

# 문제 설명

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

 * 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.


**제한사항**
---------

 * scoville의 길이는 2 이상 1,000,000 이하입니다.
 * K는 0 이상 1,000,000,000 이하입니다.
 * scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
 * 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.



**입출력 예**
-------------
scoville	| K	| return
---|---|---
[1, 2, 3, 9, 10, 12]	| 7	| 2


**입출력 예 설명**
--------------

1. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5
가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]

2. 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13
가진 음식의 스코빌 지수 = [13, 9, 10, 12]

모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.


# 풀이
```python
import heapq
def solution(scoville, K):
    answer = 0
    heapq.heapify(scoville) # 주어진 list를 heap으로 변환
    
    while(scoville[0] < K): # 가장 낮은 스코빌 지수가 K 이상이 될 때 까지 반복
        if(len(scoville) >= 2):
            first = heapq.heappop(scoville) # 가장 작은 스코빌 pop
            second = heapq.heappop(scoville) # 그 다음 작은 스코빌 pop
            mix = first + (second * 2) # 섞은 음식의 스코빌
            heapq.heappush(scoville, mix) # heap에 push
            answer += 1
        else: 
            return -1
        
    
    return answer
```

최대값, 최소값을 찾는데 매우 효율적인 Heap 알고리즘을 이용하면 쉽게 풀 수 있는 문제입니다.


**heapq 모듈 사용법**
----
import heapq
 * heapq.heappush(heap, A) : 값 A를 heap에 추가한다.
 * heapq.heappop(heap) : heap에서 가장 작은(왼쪽) 원소를 pop 
 * heapq.heapify(list) : 리스트를 heap으로 변환한다. <O(N)>


**더 높은 효율의 풀이**
----
다른 사람의 의견 중 heap보다 더 효율적인 인상적인 풀이가 있었다.
 
그것은 오직 queue만 사용하여 mix된 음식을 별도의 queue를 생성해서 따로 담는 것이다.

어차피 오름차순으로 정렬되어 있기에 별도의 queue에도 크기 순서대로 쌓일 수 밖에 없다.

이 특징을 이용해 풀면 heapq 모듈을 사용한 속도보다 두 배정도 빠르게 나온다고 한다...


**느낀점**
----
사실 Heap 자료구조는 학교에서 배워 대강 알고는 있었으나, 직접 적용해보지 않아 코딩테스트에서는 이용하지 못했었다.

그래서 이번기회에 Heap 자료구조를 다시 공부하고 문제를 풀어 보았는데, 생각보다 매우 단순해서 이걸 왜 이제 공부했나.. 후회감이 든다.

그간 응시했던 코딩테스트에서 비슷한 유형의 문제를 몇 번 마주한 적이 있었는데, 빈출도가 높은 유형이니 이번 기회에 내 것으로 만들어야 겠다.



 
 


