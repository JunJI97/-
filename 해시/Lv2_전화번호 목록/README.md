[문제링크](https://programmers.co.kr/learn/courses/30/lessons/42577)

# 문제 설명

전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

 * 구조대 : 119
 * 박준영 : 97 674 223
 * 지영석 : 11 9552 4421
 
전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.



**제한사항**
---------

 * phone_book의 길이는 1 이상 1,000,000 이하입니다.
 * 각 전화번호의 길이는 1 이상 20 이하입니다.
 * 같은 전화번호가 중복해서 들어있지 않습니다.



**입출력 예**
-------------
phone_book	| return
---|---
["119", "97674223", "1195524421"] | false
["123","456","789"]	| true
["12","123","1235","567","88"]	| false




**입출력 예 설명**
--------------
입출력 예 #1

앞에서 설명한 예와 같습니다.

입출력 예 #2

한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

입출력 예 #3

첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.



# 풀이
```python
def solution(phone_book):
    phone_book.sort() # 정렬
    for i in range(len(phone_book)-1): # -1 하는 이유는 아래 조건문 때문 (범위 이탈 방지)
        if(phone_book[i] == phone_book[i+1][0:len(phone_book[i])]): # 정렬 후 바로 옆 문자열끼리만 비교 하면 됨
            return False
    return True 
```
        
문제에서 의도한 바는 해시, 그러나 문제를 읽었을 땐 직관적으로 해시를 떠올릴 문제는 아니였던 것 같다.
주어진 문자열을 정렬하면 오름차순이든 내림차순이든 같은 접두사를 가진 전화번호끼리는 이웃할 수 밖에 없다.

이런 특징을 찾아낸다면 쉽게 풀 수 있는 문제, 난이도는 레벨1 수준인 것 같다.


**시간 복잡도**
------------------------

해당 풀이는 정렬<O(NlogN)> 후 for문을 1회<O(N)> 돌기 때문에 이론상으로는
O(NlogN) 시간복잡도를 가진다고 할 수 있다.

그러나 2중 for문 <O(N*N)>으로 단순풀이한 결과가 더 빠르다는 의견이 있었다.
이러한 의견이 나온 이유는 테스트 케이스에서 주어진 데이터의 크기가 작아서 생긴 문제일 뿐, 정렬을 거친 후 진행하는 것이 더 나은듯 하다. 

 
 


